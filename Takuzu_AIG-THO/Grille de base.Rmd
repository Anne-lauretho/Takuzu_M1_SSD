---
title: "Test"
author: "AIGOIN Emilie"
date: "2025-03-05"
output: html_document
---

Grille de Takuzu valide mais avec tout les chiffres.

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6) {
  # Créer une grille vide de n x n
  grid <- matrix(rep("", n * n), nrow = n)
  
  # Fonction pour vérifier la validité après ajout d'une valeur
  check_valid <- function(grid, row, col, value) {
    grid[row, col] <- value
    
    # Vérification des limites de 0 et 1
    if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
    if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
    
    # Vérification des séquences consécutives
    row_seq <- rle(grid[row, ])
    col_seq <- rle(grid[, col])
    
    if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
        any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
    
    if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
        any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
    
    return(TRUE)
  }
  
  # Fonction de backtracking
  backtrack <- function(grid, row = 1, col = 1) {
    if (row > n) return(grid)
    
    if (col > n) {
      return(backtrack(grid, row + 1, 1))
    }
    
    for (value in c("0", "1")) {
      if (check_valid(grid, row, col, value)) {
        grid[row, col] <- value
        result <- backtrack(grid, row, col + 1)
        if (!is.null(result)) return(result)
        grid[row, col] <- ""
      }
    }
    
    return(NULL)
  }
  
  # Générer la grille
  generated_grid <- backtrack(grid)
  
  return(generated_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(6, actionButton("check_btn", "Vérifier la grille")),
    column(6, actionButton("new_game_btn", "Nouvelle partie"))
  )
)

# Serveur
server <- function(input, output, session) {
  # Réactif pour stocker la grille
  game_grid <- reactiveVal(generate_takuzu_grid(6))
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    grid <- game_grid()
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          actionButton(
            inputId = paste0("btn_", row, "_", col),
            label = grid[row, col],
            style = "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; background-color: white;"
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        grid <- game_grid()
        current_state <- grid[row, col]
        
        # Changement cyclique : vide → 0 → 1 → vide
        new_state <- ifelse(current_state == "", "0",
                            ifelse(current_state == "0", "1", ""))
        
        grid[row, col] <- new_state
        game_grid(grid)
        
        # Mise à jour du bouton
        updateActionButton(session, btn_id, label = new_state)
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    grid <- game_grid()
    if (check_game_rules(grid)) {
      showModal(modalDialog(
        title = "Félicitations!",
        "La grille est valide!"
      ))
    } else {
      showModal(modalDialog(
        title = "Erreur",
        "La grille n'est pas valide. Continuez à essayer!"
      ))
    }
  })
  
  # Fonction de vérification des règles
  check_game_rules <- function(grid) {
    n <- nrow(grid)
    
    # Vérification de l'équilibre des 0 et 1
    for (i in 1:n) {
      if (sum(grid[i, ] == "0") != sum(grid[i, ] == "1") || 
          sum(grid[, i] == "0") != sum(grid[, i] == "1")) {
        return(FALSE)
      }
    }
    
    # Vérification des séquences
    for (i in 1:n) {
      row_seq <- rle(grid[i, ])
      col_seq <- rle(grid[, i])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
    }
    
    return(TRUE)
  }
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_grid <- generate_takuzu_grid(6)
    game_grid(new_grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Grille de Takuzu valide où on peut choisir la difficulté mais on ne peyt rajouter que des 0 après ça se bloque.

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  return(puzzle_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # Réactif pour stocker la grille
  game_grid <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    grid <- game_grid()
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          # Cellules pré-remplies sont désactivées, cellules vides sont modifiables
          is_predefined <- grid[row, col] != ""
          
          actionButton(
            inputId = paste0("btn_", row, "_", col),
            label = grid[row, col],
            disabled = is_predefined,
            style = paste0(
              "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; ",
              "background-color: ", 
              if(is_predefined) "lightgray" else "white", 
              "; color: ", 
              if(is_predefined) "black" else "blue"
            )
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        grid <- game_grid()
        
        # Ne modifier que les cellules vides
        if (grid[row, col] == "") {
          current_state <- ""
          
          # Changement cyclique : vide → 0 → 1 → vide
          new_state <- ifelse(current_state == "", "0",
                              ifelse(current_state == "0", "1", ""))
          
          grid[row, col] <- new_state
          game_grid(grid)
          
          # Mise à jour du bouton
          updateActionButton(session, btn_id, label = new_state)
        }
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    grid <- game_grid()
    complete_grid <- input$complete
    
    if (check_game_rules(grid)) {
      showModal(modalDialog(
        title = "Félicitations!",
        "La grille est valide!"
      ))
    } else {
      showModal(modalDialog(
        title = "Erreur",
        "La grille n'est pas valide. Continuez à essayer!"
      ))
    }
  })
  
  # Fonction de vérification des règles
  check_game_rules <- function(grid) {
    n <- nrow(grid)
    
    # Ne vérifier que si toutes les cellules sont remplies
    if (any(grid == "")) return(FALSE)
    
    # Vérification de l'équilibre des 0 et 1
    for (i in 1:n) {
      if (sum(grid[i, ] == "0") != sum(grid[i, ] == "1") || 
          sum(grid[, i] == "0") != sum(grid[, i] == "1")) {
        return(FALSE)
      }
    }
    
    # Vérification des séquences
    for (i in 1:n) {
      row_seq <- rle(grid[i, ])
      col_seq <- rle(grid[, i])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
    }
    
    return(TRUE)
  }
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_grid <- generate_takuzu_grid(6, input$difficulty)
    game_grid(new_grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Grille interactive où on peut changer les 0 en 1 mais on peut changer même les chiffres de base

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  return(puzzle_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur

server <- function(input, output, session) {
  game_grid <- reactiveVal(generate_takuzu_grid(6, 0.5))  # Grille initiale
  
  # Initialisation des états des boutons sous forme de liste nommée
  btn_states <- reactiveVal(NULL)  # Initialisation vide

observe({
  grid <- game_grid()  # Accéder à la grille dans un contexte réactif
  new_states <- setNames(as.list(grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
  btn_states(new_states)  # Mise à jour des états des boutons
})
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          
          actionButton(
            inputId = btn_id,
            label = btn_states()[[btn_id]],  # Utilisation des états réactifs
            style = "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        states <- btn_states()  # Récupérer les états actuels
        current_state <- states[[btn_id]]  # État du bouton cliqué
        
        # Changement cyclique : "" → "0" → "1" → ""
        new_state <- ifelse(current_state == "", "0",
                            ifelse(current_state == "0", "1", ""))
        
        states[[btn_id]] <- new_state  # Mettre à jour la valeur
        btn_states(states)  # Enregistrer la mise à jour
        updateActionButton(session, btn_id, label = new_state)  # Appliquer l'affichage
      })
    })
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
  new_grid <- generate_takuzu_grid(6, input$difficulty)
  game_grid(new_grid)
  
  new_states <- setNames(as.list(new_grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
  btn_states(new_states)  # Mettre à jour btn_states
})

}


# Lancer l'application
shinyApp(ui, server)

```

Nouveau test.

```{r}



```










