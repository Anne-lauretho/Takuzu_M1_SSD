---
title: "Test"
author: "AIGOIN Emilie"
date: "2025-03-05"
output: html_document
---

Grille de Takuzu valide mais avec tout les chiffres.

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6) {
  # Créer une grille vide de n x n
  grid <- matrix(rep("", n * n), nrow = n)
  
  # Fonction pour vérifier la validité après ajout d'une valeur
  check_valid <- function(grid, row, col, value) {
    grid[row, col] <- value
    
    # Vérification des limites de 0 et 1
    if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
    if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
    
    # Vérification des séquences consécutives
    row_seq <- rle(grid[row, ])
    col_seq <- rle(grid[, col])
    
    if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
        any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
    
    if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
        any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
    
    return(TRUE)
  }
  
  # Fonction de backtracking
  backtrack <- function(grid, row = 1, col = 1) {
    if (row > n) return(grid)
    
    if (col > n) {
      return(backtrack(grid, row + 1, 1))
    }
    
    for (value in c("0", "1")) {
      if (check_valid(grid, row, col, value)) {
        grid[row, col] <- value
        result <- backtrack(grid, row, col + 1)
        if (!is.null(result)) return(result)
        grid[row, col] <- ""
      }
    }
    
    return(NULL)
  }
  
  # Générer la grille
  generated_grid <- backtrack(grid)
  
  return(generated_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(6, actionButton("check_btn", "Vérifier la grille")),
    column(6, actionButton("new_game_btn", "Nouvelle partie"))
  )
)

# Serveur
server <- function(input, output, session) {
  # Réactif pour stocker la grille
  game_grid <- reactiveVal(generate_takuzu_grid(6))
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    grid <- game_grid()
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          actionButton(
            inputId = paste0("btn_", row, "_", col),
            label = grid[row, col],
            style = "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; background-color: white;"
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        grid <- game_grid()
        current_state <- grid[row, col]
        
        # Changement cyclique : vide → 0 → 1 → vide
        new_state <- ifelse(current_state == "", "0",
                            ifelse(current_state == "0", "1", ""))
        
        grid[row, col] <- new_state
        game_grid(grid)
        
        # Mise à jour du bouton
        updateActionButton(session, btn_id, label = new_state)
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    grid <- game_grid()
    if (check_game_rules(grid)) {
      showModal(modalDialog(
        title = "Félicitations!",
        "La grille est valide!"
      ))
    } else {
      showModal(modalDialog(
        title = "Erreur",
        "La grille n'est pas valide. Continuez à essayer!"
      ))
    }
  })
  
  # Fonction de vérification des règles
  check_game_rules <- function(grid) {
    n <- nrow(grid)
    
    # Vérification de l'équilibre des 0 et 1
    for (i in 1:n) {
      if (sum(grid[i, ] == "0") != sum(grid[i, ] == "1") || 
          sum(grid[, i] == "0") != sum(grid[, i] == "1")) {
        return(FALSE)
      }
    }
    
    # Vérification des séquences
    for (i in 1:n) {
      row_seq <- rle(grid[i, ])
      col_seq <- rle(grid[, i])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
    }
    
    return(TRUE)
  }
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_grid <- generate_takuzu_grid(6)
    game_grid(new_grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Grille de Takuzu valide où on peut choisir la difficulté mais on ne peyt rajouter que des 0 après ça se bloque.

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  return(puzzle_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # Réactif pour stocker la grille
  game_grid <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    grid <- game_grid()
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          # Cellules pré-remplies sont désactivées, cellules vides sont modifiables
          is_predefined <- grid[row, col] != ""
          
          actionButton(
            inputId = paste0("btn_", row, "_", col),
            label = grid[row, col],
            disabled = is_predefined,
            style = paste0(
              "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; ",
              "background-color: ", 
              if(is_predefined) "lightgray" else "white", 
              "; color: ", 
              if(is_predefined) "black" else "blue"
            )
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        grid <- game_grid()
        
        # Ne modifier que les cellules vides
        if (grid[row, col] == "") {
          current_state <- ""
          
          # Changement cyclique : vide → 0 → 1 → vide
          new_state <- ifelse(current_state == "", "0",
                              ifelse(current_state == "0", "1", ""))
          
          grid[row, col] <- new_state
          game_grid(grid)
          
          # Mise à jour du bouton
          updateActionButton(session, btn_id, label = new_state)
        }
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    grid <- game_grid()
    complete_grid <- input$complete
    
    if (check_game_rules(grid)) {
      showModal(modalDialog(
        title = "Félicitations!",
        "La grille est valide!"
      ))
    } else {
      showModal(modalDialog(
        title = "Erreur",
        "La grille n'est pas valide. Continuez à essayer!"
      ))
    }
  })
  
  # Fonction de vérification des règles
  check_game_rules <- function(grid) {
    n <- nrow(grid)
    
    # Ne vérifier que si toutes les cellules sont remplies
    if (any(grid == "")) return(FALSE)
    
    # Vérification de l'équilibre des 0 et 1
    for (i in 1:n) {
      if (sum(grid[i, ] == "0") != sum(grid[i, ] == "1") || 
          sum(grid[, i] == "0") != sum(grid[, i] == "1")) {
        return(FALSE)
      }
    }
    
    # Vérification des séquences
    for (i in 1:n) {
      row_seq <- rle(grid[i, ])
      col_seq <- rle(grid[, i])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) {
        return(FALSE)
      }
    }
    
    return(TRUE)
  }
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_grid <- generate_takuzu_grid(6, input$difficulty)
    game_grid(new_grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Grille interactive où on peut changer les 0 en 1 mais on peut changer même les chiffres de base

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  return(puzzle_grid)
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur

server <- function(input, output, session) {
  game_grid <- reactiveVal(generate_takuzu_grid(6, 0.5))  # Grille initiale
  
  # Initialisation des états des boutons sous forme de liste nommée
  btn_states <- reactiveVal(NULL)  # Initialisation vide

observe({
  grid <- game_grid()  # Accéder à la grille dans un contexte réactif
  new_states <- setNames(as.list(grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
  btn_states(new_states)  # Mise à jour des états des boutons
})
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          
          actionButton(
            inputId = btn_id,
            label = btn_states()[[btn_id]],  # Utilisation des états réactifs
            style = "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        states <- btn_states()  # Récupérer les états actuels
        current_state <- states[[btn_id]]  # État du bouton cliqué
        
        # Changement cyclique : "" → "0" → "1" → ""
        new_state <- ifelse(current_state == "", "0",
                            ifelse(current_state == "0", "1", ""))
        
        states[[btn_id]] <- new_state  # Mettre à jour la valeur
        btn_states(states)  # Enregistrer la mise à jour
        updateActionButton(session, btn_id, label = new_state)  # Appliquer l'affichage
      })
    })
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
  new_grid <- generate_takuzu_grid(6, input$difficulty)
  game_grid(new_grid)
  
  new_states <- setNames(as.list(new_grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
  btn_states(new_states)  # Mettre à jour btn_states
})

}


# Lancer l'application
shinyApp(ui, server)

```

Cases bloquées et cases à modifier mais qui ne correspondent pas à celles de déaprt.

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  # Créer une matrice de booléens pour indiquer les cellules fixes
  fixed_cells_matrix <- matrix(puzzle_grid != "", nrow = n)
  
  return(list(
    grid = puzzle_grid,
    fixed_cells = fixed_cells_matrix  # Matrice booléenne des cellules fixes
  ))
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # Maintenant, game_data contient à la fois la grille et les indices des cellules fixes
  game_data <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Les états des boutons
  btn_states <- reactiveVal(NULL)
  
  # Initialiser les états des boutons
  observe({
    data <- game_data()
    grid <- data$grid
    new_states <- setNames(as.list(grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
    btn_states(new_states)
  })
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    data <- game_data()
    fixed_cells <- data$fixed_cells
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          current_value <- btn_states()[[btn_id]]
          
          # Vérifier si cette cellule est fixe en utilisant la matrice booléenne
          is_fixed <- fixed_cells[row, col]
          
          # Style différent pour les cellules fixes
          button_style <- if (is_fixed) {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; background-color: #e0e0e0; font-weight: bold;"
          } else {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          }
          
          actionButton(
            inputId = btn_id,
            label = current_value,
            style = button_style
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        data <- game_data()
        fixed_cells <- data$fixed_cells
        
        # Vérifier si cette cellule est fixe en utilisant la matrice booléenne
        if (!fixed_cells[row, col]) {
          states <- btn_states()
          current_state <- states[[btn_id]]
          
          # Changement cyclique : "" → "0" → "1" → ""
          new_state <- ifelse(current_state == "", "0",
                              ifelse(current_state == "0", "1", ""))
          
          states[[btn_id]] <- new_state
          btn_states(states)
          updateActionButton(session, btn_id, label = new_state)
        }
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    # Vous pouvez implémenter ici la logique de vérification
    # Par exemple, vérifier si toutes les règles du Takuzu sont respectées
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_data <- generate_takuzu_grid(6, input$difficulty)
    game_data(new_data)
    
    grid <- new_data$grid
    new_states <- setNames(as.list(grid), paste0("btn_", rep(1:6, each = 6), "_", rep(1:6, times = 6)))
    btn_states(new_states)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Boutons qui fonctionnent correctement !

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  solution <- complete_grid  # Sauvegarder la solution complète
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  # Créer une matrice booléenne pour les cellules initialement remplies
  initial_filled <- puzzle_grid != ""
  
  return(list(
    grid = puzzle_grid,
    solution = solution,
    initial_filled = initial_filled
  ))
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # État du jeu actuel
  game_data <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Valeurs actuelles des cellules
  cell_values <- reactiveVal(matrix("", 6, 6))
  
  # Initialiser les valeurs des cellules
  observe({
    data <- game_data()
    cell_values(data$grid)
  })
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    data <- game_data()
    values <- cell_values()
    initial_filled <- data$initial_filled
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          current_value <- values[row, col]
          
          # Vérifier si cette cellule est initialement remplie
          is_fixed <- initial_filled[row, col]
          
          # Style différent pour les cellules fixes
          button_style <- if (is_fixed) {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px; background-color: #e0e0e0; font-weight: bold;"
          } else {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          }
          
          actionButton(
            inputId = btn_id,
            label = current_value,
            style = button_style
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        data <- game_data()
        initial_filled <- data$initial_filled
        
        # Ne pas permettre la modification des cellules initialement remplies
        if (!initial_filled[row, col]) {
          values <- cell_values()
          current_value <- values[row, col]
          
          # Changement cyclique : "" → "0" → "1" → ""
          new_value <- ifelse(current_value == "", "0",
                            ifelse(current_value == "0", "1", ""))
          
          values[row, col] <- new_value
          cell_values(values)
          updateActionButton(session, btn_id, label = new_value)
        }
      })
    })
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    data <- game_data()
    values <- cell_values()
    
    # Vérifier que toutes les cellules sont remplies
    if (any(values == "")) {
      showModal(modalDialog(
        "Veuillez remplir toutes les cellules avant de vérifier.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Vérifier si la grille est valide selon les règles du Takuzu
    # (Cette implémentation est simplifiée, vous pourriez vouloir ajouter des vérifications plus complètes)
    correct <- all(values == data$solution)
    
    showModal(modalDialog(
      if (correct) "Bravo ! Vous avez résolu le puzzle correctement." 
      else "Il y a des erreurs dans votre solution. Continuez à essayer.",
      easyClose = TRUE
    ))
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_data <- generate_takuzu_grid(6, input$difficulty)
    game_data(new_data)
    cell_values(new_data$grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Pouvoir choisir la couleur des cases bloquées

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)
library(colourpicker)  # Pour le sélecteur de couleur

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  solution <- complete_grid  # Sauvegarder la solution complète
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  # Créer une matrice booléenne pour les cellules initialement remplies
  initial_filled <- puzzle_grid != ""
  
  return(list(
    grid = puzzle_grid,
    solution = solution,
    initial_filled = initial_filled
  ))
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Ajout du sélecteur de couleur en haut à droite
  tags$div(
    style = "position: absolute; top: 10px; right: 10px;",
    colourInput("fixed_cell_color", "Couleur des cases initiales", "#e0e0e0")
  ),
  
  # Espacement pour éviter la superposition
  tags$div(style = "height: 60px;"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # État du jeu actuel
  game_data <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Valeurs actuelles des cellules
  cell_values <- reactiveVal(matrix("", 6, 6))
  
  # Initialiser les valeurs des cellules
  observe({
    data <- game_data()
    cell_values(data$grid)
  })
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    data <- game_data()
    values <- cell_values()
    initial_filled <- data$initial_filled
    fixed_color <- input$fixed_cell_color
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          current_value <- values[row, col]
          
          # Vérifier si cette cellule est initialement remplie
          is_fixed <- initial_filled[row, col]
          
          # Style différent pour les cellules fixes
          button_style <- if (is_fixed) {
            sprintf("width: 100%%; aspect-ratio: 1 / 1; font-size: 16px; background-color: %s; font-weight: bold;", fixed_color)
          } else {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          }
          
          actionButton(
            inputId = btn_id,
            label = current_value,
            style = button_style
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        data <- game_data()
        initial_filled <- data$initial_filled
        
        # Ne pas permettre la modification des cellules initialement remplies
        if (!initial_filled[row, col]) {
          values <- cell_values()
          current_value <- values[row, col]
          
          # Changement cyclique : "" → "0" → "1" → ""
          new_value <- ifelse(current_value == "", "0",
                            ifelse(current_value == "0", "1", ""))
          
          values[row, col] <- new_value
          cell_values(values)
          updateActionButton(session, btn_id, label = new_value)
        }
      })
    })
  })
  
  # Mettre à jour les styles des boutons lorsque la couleur change
  observeEvent(input$fixed_cell_color, {
    data <- game_data()
    initial_filled <- data$initial_filled
    fixed_color <- input$fixed_cell_color
    
    # Parcourir toutes les cellules fixes et mettre à jour leur style
    for (row in 1:6) {
      for (col in 1:6) {
        if (initial_filled[row, col]) {
          btn_id <- paste0("btn_", row, "_", col)
          runjs(sprintf(
            "$('#%s').css('background-color', '%s');",
            btn_id, fixed_color
          ))
        }
      }
    }
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    data <- game_data()
    values <- cell_values()
    
    # Vérifier que toutes les cellules sont remplies
    if (any(values == "")) {
      showModal(modalDialog(
        "Veuillez remplir toutes les cellules avant de vérifier.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Vérifier si la grille est valide selon les règles du Takuzu
    correct <- all(values == data$solution)
    
    showModal(modalDialog(
      if (correct) "Bravo ! Vous avez résolu le puzzle correctement." 
      else "Il y a des erreurs dans votre solution. Continuez à essayer.",
      easyClose = TRUE
    ))
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_data <- generate_takuzu_grid(6, input$difficulty)
    game_data(new_data)
    cell_values(new_data$grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```

Choix entre quelques couleurs 

```{r}

library(shiny)
library(shinydashboard)
library(shinyjs)
library(shinyWidgets)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  # Générer une grille complète valide
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      
      if (col > n) {
        return(backtrack(grid, row + 1, 1))
      }
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  # Générer une grille complète
  complete_grid <- full_grid()
  solution <- complete_grid  # Sauvegarder la solution complète
  
  # Créer la grille de puzzle en laissant certaines cellules vides
  puzzle_grid <- complete_grid
  
  # Calculer le nombre de cellules à laisser vides
  cells_to_remove <- round(n * n * difficulty)
  
  # Supprimer des cellules de manière aléatoire
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  # Créer une matrice booléenne pour les cellules initialement remplies
  initial_filled <- puzzle_grid != ""
  
  return(list(
    grid = puzzle_grid,
    solution = solution,
    initial_filled = initial_filled
  ))
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  # Sélecteur de couleur parmi quelques options prédéfinies
  tags$div(
    style = "position: absolute; top: 10px; right: 10px;",
    pickerInput(
  inputId = "fixed_cell_color", 
  label = "Couleur des cases initiales", 
  choices = c("Gris clair" = "#e0e0e0", "Bleu" = "#add8e6", "Vert" = "#cdecc5", "Jaune" = "#fffacd", "Rose" = "#e7c5ec"), 
  choicesOpt = list(
    style = c(
      "background-color: #e0e0e0; color: black;", 
      "background-color: #add8e6; color: black;", 
      "background-color: #cdecc5; color: black;", 
      "background-color: #fffacd; color: black;",
      "background-color: #e7c5ec; color: black;"
    )
  ),
  selected = "#e0e0e0"
)
  ),
  
  # Espacement pour éviter la superposition
  tags$div(style = "height: 60px;"),
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4, sliderInput("difficulty", "Difficulté", 
                          min = 0.1, max = 0.8, value = 0.5, step = 0.1))
  )
)

# Serveur
server <- function(input, output, session) {
  # État du jeu actuel
  game_data <- reactiveVal(generate_takuzu_grid(6, 0.5))
  
  # Valeurs actuelles des cellules
  cell_values <- reactiveVal(matrix("", 6, 6))
  
  # Initialiser les valeurs des cellules
  observe({
    data <- game_data()
    cell_values(data$grid)
  })
  
  # Génération dynamique de la grille UI
  output$grid_ui <- renderUI({
    data <- game_data()
    values <- cell_values()
    initial_filled <- data$initial_filled
    fixed_color <- input$fixed_cell_color
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          current_value <- values[row, col]
          
          # Vérifier si cette cellule est initialement remplie
          is_fixed <- initial_filled[row, col]
          
          # Style différent pour les cellules fixes
          button_style <- if (is_fixed) {
            sprintf("width: 100%%; aspect-ratio: 1 / 1; font-size: 16px; background-color: %s; font-weight: bold;", fixed_color)
          } else {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          }
          
          actionButton(
            inputId = btn_id,
            label = current_value,
            style = button_style
          )
        })
      })
    )
  })
  
  # Gestion des clics sur les cellules
  lapply(1:6, function(row) {
    lapply(1:6, function(col) {
      btn_id <- paste0("btn_", row, "_", col)
      
      observeEvent(input[[btn_id]], {
        data <- game_data()
        initial_filled <- data$initial_filled
        
        # Ne pas permettre la modification des cellules initialement remplies
        if (!initial_filled[row, col]) {
          values <- cell_values()
          current_value <- values[row, col]
          
          # Changement cyclique : "" → "0" → "1" → ""
          new_value <- ifelse(current_value == "", "0",
                            ifelse(current_value == "0", "1", ""))
          
          values[row, col] <- new_value
          cell_values(values)
          updateActionButton(session, btn_id, label = new_value)
        }
      })
    })
  })
  
  # Mettre à jour les styles des boutons lorsque la couleur change
  observeEvent(input$fixed_cell_color, {
    data <- game_data()
    initial_filled <- data$initial_filled
    fixed_color <- input$fixed_cell_color
    
    # Parcourir toutes les cellules fixes et mettre à jour leur style
    for (row in 1:6) {
      for (col in 1:6) {
        if (initial_filled[row, col]) {
          btn_id <- paste0("btn_", row, "_", col)
          runjs(sprintf(
            "$('#%s').css('background-color', '%s');",
            btn_id, fixed_color
          ))
        }
      }
    }
  })
  
  # Vérification de la grille
  observeEvent(input$check_btn, {
    data <- game_data()
    values <- cell_values()
    
    # Vérifier que toutes les cellules sont remplies
    if (any(values == "")) {
      showModal(modalDialog(
        "Veuillez remplir toutes les cellules avant de vérifier.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Vérifier si la grille est valide selon les règles du Takuzu
    correct <- all(values == data$solution)
    
    showModal(modalDialog(
      if (correct) "Bravo ! Vous avez résolu le puzzle correctement." 
      else "Il y a des erreurs dans votre solution. Continuez à essayer.",
      easyClose = TRUE
    ))
  })
  
  # Nouvelle partie
  observeEvent(input$new_game_btn, {
    new_data <- generate_takuzu_grid(6, input$difficulty)
    game_data(new_data)
    cell_values(new_data$grid)
  })
}

# Lancer l'application
shinyApp(ui, server)


```

Avec la barre de difficulté qui change aussi de couleur mais les chiffres ne changent plus

```{r}

library(shiny)
library(shinyjs)
library(shinyWidgets)

# Fonction de génération de grille Takuzu
generate_takuzu_grid <- function(n = 6, difficulty = 0.5) {
  full_grid <- function() {
    grid <- matrix(rep("", n * n), nrow = n)
    
    check_valid <- function(grid, row, col, value) {
      grid[row, col] <- value
      
      if (sum(grid[row, ] == "0") > n / 2 || sum(grid[row, ] == "1") > n / 2) return(FALSE)
      if (sum(grid[, col] == "0") > n / 2 || sum(grid[, col] == "1") > n / 2) return(FALSE)
      
      row_seq <- rle(grid[row, ])
      col_seq <- rle(grid[, col])
      
      if (any(row_seq$lengths[row_seq$values == "0"] >= 3) || 
          any(row_seq$lengths[row_seq$values == "1"] >= 3)) return(FALSE)
      
      if (any(col_seq$lengths[col_seq$values == "0"] >= 3) || 
          any(col_seq$lengths[col_seq$values == "1"] >= 3)) return(FALSE)
      
      return(TRUE)
    }
    
    backtrack <- function(grid, row = 1, col = 1) {
      if (row > n) return(grid)
      if (col > n) return(backtrack(grid, row + 1, 1))
      
      for (value in c("0", "1")) {
        if (check_valid(grid, row, col, value)) {
          grid[row, col] <- value
          result <- backtrack(grid, row, col + 1)
          if (!is.null(result)) return(result)
          grid[row, col] <- ""
        }
      }
      return(NULL)
    }
    
    return(backtrack(grid))
  }
  
  complete_grid <- full_grid()
  
  puzzle_grid <- complete_grid
  cells_to_remove <- round(n * n * difficulty)
  remove_indices <- sample(1:(n*n), cells_to_remove)
  puzzle_grid[remove_indices] <- ""
  
  initial_filled <- puzzle_grid != ""
  
  return(list(
    grid = puzzle_grid,
    solution = complete_grid,
    initial_filled = initial_filled
  ))
}

# UI
ui <- fluidPage(
  useShinyjs(),
  titlePanel("Jeu de Takuzu"),
  
  tags$div(
    style = "position: absolute; top: 10px; right: 10px;",
    pickerInput(
      inputId = "fixed_cell_color", 
      label = "Couleur des cases initiales", 
      choices = c(
        "Gris clair" = "#e0e0e0", 
        "Bleu" = "#add8e6", 
        "Vert" = "#cdecc5", 
        "Jaune" = "#fffacd", 
        "Rose" = "#e7c5ec"
      ), 
      choicesOpt = list(
        style = c(
          "background-color: #e0e0e0; color: black;", 
          "background-color: #add8e6; color: black;", 
          "background-color: #cdecc5; color: black;", 
          "background-color: #fffacd; color: black;",
          "background-color: #e7c5ec; color: black;"
        )
      ),
      selected = "#e0e0e0"
    )
  ),
  
  tags$div(style = "height: 60px;"), 
  
  # Grille interactive
  uiOutput("grid_ui"),
  
  # Boutons de contrôle
  fluidRow(
    column(4, actionButton("check_btn", "Vérifier la grille")),
    column(4, actionButton("new_game_btn", "Nouvelle partie")),
    column(4,
      sliderInput("difficulty", "Difficulté", 
                  min = 1, max = 10, value = 5, step = 1)
    )
  ),
  
  # ✅ Ajout d'un style personnalisé pour le slider
  tags$style("
    .slider-container .irs-bar, 
    .slider-container .irs-bar-edge, 
    .slider-container .irs-single {
      background-color: #e0e0e0 !important;
      border-color: #e0e0e0 !important;
    }
  ")
)

# Serveur
server <- function(input, output, session) {
  game_data <- reactiveVal(generate_takuzu_grid(6, 0.5))
  cell_values <- reactiveVal(matrix("", 6, 6))
  
  observe({
    data <- game_data()
    cell_values(data$grid)
  })
  
  output$grid_ui <- renderUI({
    data <- game_data()
    values <- cell_values()
    initial_filled <- data$initial_filled
    fixed_color <- input$fixed_cell_color
    
    tags$div(
      style = "display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; width: 300px; margin: auto;",
      lapply(1:6, function(row) {
        lapply(1:6, function(col) {
          btn_id <- paste0("btn_", row, "_", col)
          current_value <- values[row, col]
          is_fixed <- initial_filled[row, col]
          
          button_style <- if (is_fixed) {
            sprintf("width: 100%%; aspect-ratio: 1 / 1; font-size: 16px; background-color: %s; font-weight: bold;", fixed_color)
          } else {
            "width: 100%; aspect-ratio: 1 / 1; font-size: 16px;"
          }
          
          actionButton(
            inputId = btn_id,
            label = current_value,
            style = button_style
          )
        })
      })
    )
  })
  
  # ✅ Changement de couleur dynamique des cases fixes + barre de difficulté
  observeEvent(input$fixed_cell_color, {
    fixed_color <- input$fixed_cell_color
    data <- game_data()
    
    # Mise à jour de la couleur des cases fixes
    for (row in 1:6) {
      for (col in 1:6) {
        if (data$initial_filled[row, col]) {
          btn_id <- paste0("btn_", row, "_", col)
          runjs(sprintf("$('#%s').css('background-color', '%s');", btn_id, fixed_color))
        }
      }
    }
    
    # ✅ Mise à jour de la couleur du slider
    runjs(sprintf("
      $('.irs-bar, .irs-bar-edge, .irs-single').css('background-color', '%s');
      $('.irs-bar, .irs-bar-edge, .irs-single').css('border-color', '%s');
    ", fixed_color, fixed_color))
  })
  
  observeEvent(input$check_btn, {
    data <- game_data()
    values <- cell_values()
    
    if (any(values == "")) {
      showModal(modalDialog("Veuillez remplir toutes les cellules.", easyClose = TRUE))
      return()
    }
    
    correct <- all(values == data$solution)
    
    showModal(modalDialog(
      if (correct) "Bravo ! Solution correcte !" else "Il y a des erreurs.",
      easyClose = TRUE
    ))
  })
  
  observeEvent(input$new_game_btn, {
    new_data <- generate_takuzu_grid(6, input$difficulty)
    game_data(new_data)
    cell_values(new_data$grid)
  })
}

# Lancer l'application
shinyApp(ui, server)

```



```{r}


```



















